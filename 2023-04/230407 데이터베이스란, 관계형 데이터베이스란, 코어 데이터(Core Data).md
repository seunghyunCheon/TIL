230407 데이터베이스란, 관계형 데이터베이스란, 코어 데이터(Core Data)
===
학습내용
- 데이터베이스란
- 관계형 데이터베이스란
- 코어 데이터(Core Data)

## 데이터베이스란
여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합.
여러 응용 시스템들의 통합된 정보들을 저장하여 운영할 수 있는 공용 데이터들의 묶음.

### 역사
1950년대 미국에서 국비의 집중, 효율적 관리를 위해 컴퓨터를 활용한 도서관 개념을 개발하면서 데이터베이스로 일컬었다. 
1965년 시스템 디벨로프사가 2차로 개최한 컴퓨터 중심 데이터베이스 시스템이라는 심포지엄에서 처음 사용하였다.

프로세서, 컴퓨터 메모리, 컴퓨터 스토리지, 컴퓨터 네트워크 분야에서 기술이 진전되면서 DBMS의 크기, 기능, 성능이 상승해왔으며 데이터베이스 기술의 발전은 데이터 모델이나 구조에 따라 세 개의 시대로 나뉜다.(내비게이셔널 데이터베이스, SQL/관계형 데이터베이스, 관계형 이후 데이터베이스)

1970년 애드거 F.커드가 처음 제안한 관계형 모델은 응용 프로그램들이 뒷따르는 링크가 아닌 내용을 기준으로 데이터를 검색해야 한다고 주장하면서 출발했다. 관계형 모델은 금전출납부 스타일의 표들의 모임을 이용하며, 각각은 다른 타입의 엔티티를 위해 사용된다. 
1980년대 컴퓨팅 하드웨어가 비로소 관계형 시스템(DBMS + 애플리케이션)의 폭넓은 배치를 가능케 할 만큼 강력해졌고 1990년대 초 모든 데이터 처리 애플리케이션을 관계형 시스템들이 지배하게 되었다. 현재도 상황이 동일. 

2000년대 말에 관계형 이후의 차세대 데이터베이스로 NoSQL데이터베이스로 알려지게 되었으며, 고속의 키-값 스토어, 도큐먼트 지향 데이터베이스를 도입함.

### 데이터베이스의 개념
여러 사람이 공유하고 사용할 목적으로 통합 관리되는 정보의 집합. 논리적으로 연관된 하나 이상의 자료의 모음으로 그 내용을 고도로 구조화함으로써 검색과 갱신의 효율화를 꾀한 것이다. 즉 몇 개의 자료 파일을 조직적으로 통합하여 자료 항목의 중복을 없애고 자료를 구조화하여 기억시켜 놓은 자료의 집합체라고 할 수 있다.

#### 특징
- 실시간 접근성
- 지속적인 변화
- 동시 공유
- 내용에 대한 참조
- 데이터 논리적 독립성

#### 장점
- 데이터 중복 최소화
- 데이터 공유
- 일관성, 무결성, 보안성 유지
- 최신의 데이터 유지
- 요이한 데이터 접근
- 데이터 저장 공간 절약
- 데이터의 논리적, 물리적 독립성

#### 단점
- 데이터베이스 전문가 필요
- 많은 비용 부담
- 데이터 백업과 복구가 어려움
- 시스템의 복잡함
- 대용량 디스크로 액세스가 집중되면 과부화 발생

## 관계형 데이터베이스
키와 값들의 간단한 관계를 테이블화 시킨 매우 간단한 원칙의 전산정보 데이터베이스. 1970년 에드거 F. 커드가 제안한 데이터 관계형 모델에 기초하는 디지털 데이터베이스이다. 

이 모델은 데이터를 컬럼과 로우를 이루는 하나 이상의 테이블(또는 관계)로 정리하며, 고유 키가 각 로우를 식별한다. 로우는 레코드나 튜플로 부른다. 일반적으로 각 테이블/관계는 하나의 엔티티타입을 대표한다. 로우는 그 엔티티 종류의 인스턴스(예: "Lee")를 대표하며 컬럼은 그 인스턴스의 속성이 되는 값들을 대표한다.

### 키
테이블의 각 로우에는 저만의 고유 키가 있다. 한 테이블 안의 로우는 다른 테이블들의 로우로 연결이 가능한데, 이는 연결된 로우의 고유 키를 위한 컬럼을 추가함으로써 이루어진다.(이러한 컬럼을 외래 키라 부름.)

관계는 테이블 간에 둘 다 존재한다. 이 관계들은 일대일, 일대다, 다대다 세 가지 형태로 이루어진다. 대부분의 관계형 데이터베이스들은 각 로우의 각 컬럼이 하나의 값만을 보유할 수 있도록 설계되어있다. (값은 원자적이다)

### 트랜잭션
데이터베이스 관리 시스템이 효율적이고 정확하게 운용되기 위해서는 ACID 트랜잭션을 갖추고 있어야 한다.

## 코어 데이터(Core Data)
단일 디바이스에 데이터를 지속 혹은 캐시한다. 또는 CloudKit을 이용해 다중 디바이스의 데이터를 동기화한다.

### Overview
Core Data를 사용하여 오프라인 사용을 위해 애플리케이션의 영구 데이터를 저장하고, 임시 데이터를 캐시하고, 단일 기기에서 앱에 실행 취소 기능을 추가한다. 단일 iCloud계정 안의 다중 디바이스의 데이터를 동기화하기 위해 코어 데이터는 자동으로 CloudKit 컨테이너에 스키마를 미러링한다.

Core Data의 데이터 모델 editor를 통해 데이터 타입과 관계를 정의하고 각각의 class 정의를 생성한다. 그 후 Core Data는 다음의 기능을 제공하기위해 런타임에 객체 인스턴스들을 관리할 수 있게된다.

### Persistence
Core Data는 데이터베이스를 직접적으로 관리하는 것없이 Swift나 Objective-C로부터 데이터를 쉽게 저장함으로써 저장소에 특정 객체에 매핑되는 상세정보를 추상화한다. 

<img src="https://i.imgur.com/rIz2itB.png" width="500"/><br/>

### Undo and Redo of Individual or Batched Changes

Core Data의 undo manager는 변화를 추적하고 개별적으로 

Core Data의 undo manager는 변경 사항을 추적하고 개별적으로, 그룹으로 또는 한 번에 모두 롤백할 수 있으므로 앱에 실행 취소 및 다시 실행 지원을 쉽게 추가할 수 있다.

<img src="https://i.imgur.com/sxGGtLC.png" width="500"/><br/>

### Background Data Tasks

JSON을 객체로 파싱하는것 처럼 잠재적으로 UI를 차단하는 데이터 작업을 백그라운드 작업에서 수행한다. 그런 다음 결과를 캐시하거나 저장하여 서버 왕복을 줄일 수 있다.

### View Synchronization

Core Data는 테이블, 컬렉션 뷰에 데이터 소스를 제공함으로써 뷰와 데이터를 동기화시키도록 돕는다.

### Versioning and Mirgration
Core Data는 앱이 발전함에 따라 데이터 모델의 버전을 관리하고 사용자 데이터를 마이그레이션하는 메커니즘을 가지고 있다.


## ---------------------

### 코어데이터
코어데이터의 본질은 라이프사이클, 검색, 영속성 기능을 가진 객체 그래프 관리자이다.
객체 그래프 관리는 다음을 포함한다.
- 객체 A를 객체 B와 연결할 수 있으며, 해당 연결은 영속적으로 동기화 된다. A쪽에서 연결을 변경하면, B가 업데이트 되면서 그에따른 알림(notification)을 발생시킨다(이 알림에 대해 임의의 코드를 짜넣어서 실행하는 것이 가능).
- 한쪽에서 객체를 삭제할 경우 연결을 타고 cascade 삭제가 일어나도록 할수도있고, nullify 시켜서 해당 객체만 삭제 할 수도 있다.


코어데이터는 완전한 인메모리 형태로 사용이 가능하다. 즉 코어데이터는 반드시 영속성 특성을 이용하기 위해 사용되는 개념은 아닌 것이다. 

그리고 어떠한 형태의 검색기능 없이 사용이 가능하다. 일단 객체들이 할당되고 연결되었을 경우, 한 객체에만 접근이 가능하다면, 추가적인 불러오기(fetch)없이 해당 객체로부터 나머지 연결된 객체에 접근이 가능하다. 

모든 코어데이터 객체들은 완전히 인스턴스화된 Objective-C객체이며 속성값과 관계, 라이프사이클을 관리하는 것이 가능하다. 이는 객체들의 속성들과 동작들이 메서드에 의해 구현될 수 있음을 의미하며 이러한 메서드들은 서브 클래싱을 통해 옵저브와 오버라이드가 가능해진다.

### 대표적인 데이터베이스의 종류
#### 계층형 데이터베이스(HDBMS)
- 폴더와 파일 등의 계층 구조로 데이터를 저장하는 방식
- 하드디스크, DVD 파일 시스템
- 데이터 엑세스 속도가 빠름
- 상하 종속적인 관계로 구성되어 초기 세팅 후 프로세스 수용이 어려움

#### 네트워크형 데이터베이스(NDBMS)
- 데이터 구조를 네트워크상의 노드 형태로 논리적이게 표현한 데이터 모델. 각각의 노드를 서로 대등한 관계로 구성한 시스템
- 계층형 데이터베이스의 데이터 중복 문제를 해결하고 상하 종속적 관계를 해결
- 추후 변경 시 복잡한 구조로 인해 변경이 어렵다
- 데이터 종속성을 해결하지 못함(종속성: 응용 프로그램과 데이터 간의 상호 의존관계)


#### 관계형 데이터베이스(RDBMS)
- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
- 다양한 용도로 사용 가능, 높은 성능
- 데이터 무결성 보장. 높은 신뢰성
- 정규화에 따른 갱신 비용 최소화
- 데이터의 분류, 정렬, 탐색 속도가 빠름
- 컬럼 확장이 어려움. -> 유연성 부족
- 수평 확장의 어려움

#### 객체지향 데이터베이스(ODBMS)
- 객체 그대로를 데이터베이스의 데이터에 저장하는 것
- RDBMS의 비즈니스형 데이터 타입만 처리되는 제한적 극복

#### NoSQL
- 키 - 값의 형태로 저장되는 데이터베이스. 키를 사용해 데이터 관리 및 접근
- 스키마와 관계가 없다.
- Join이 존재하지 않고 데이터를 가져올 때, 컬렉션에 있는 데이터를 복제하여 필요한 데이터의 일부만 가져옴
- NoSQL은 비정형 데이터(메신저 텍스트, 음성, 이미지)를 다룰 수 있다.

### 데이터베이스와 데이터베이스 관리 시스템의 차이
데이터베이스는 데이터의 집합이라고 정의한다면 이런 데이터베이스를 관리하고 운영하는 소프트웨어를 DBMS라고 한다. 

<img src="https://i.imgur.com/Kvc30XJ.png" width="500"/>

### 코어데이터 장단점
#### 장점
- DBMS에 대한 종속성이 절감된다
- 독립적으로 작성되어 재사용 및 유지보수가 편리하다
- CloudKit을 사용하여 다른 기기들과 연동할 수 있다

#### 단점
- in-memory 방식이기에 메모리에 로딩된 객체에 대해서만 수정이 가능(SQLite은 모두 메모리에 로딩하지 않아도 최소한의 데이터만 로드하여 가능)
- thread-safe하지 않다.(멀티 스레드 환경에서 스레드 사이의 lock기능이 존재하지 않음)
- 중복된 값의 입력을 방지하는 Unique Key가 없으므로 애플리케이션에서 비즈니스 로직을 통해 처리해야 함

### 코어데이터 모델 변경시 주의점
모델을 변경하고 마이그레이션을 해야 한다. [코어데이터 변경 및 마이그레이션](https://yeonduing.tistory.com/48)

### 코어데이터가 관리할 수 있는 영구 저장소 타입의 종류
#### 인메모리 저장소 타입
- 메모리 기반의 저장 방식(영구 저장소를 사용하지 않음)
- 앱 종료시 데이터 보존이 되지 않음

#### 플랫 바이너리 저장소 타입
- 데이터를 단순 바이너리 파일 형식으로 저장
- 장점은 조회 성능 개선, 단점은 초기 로딩 시간 증가

#### XML 저장소 타입
- 원자성
- 장점은 직접 열어보고 확인 가능. 단점은 처리속도가 느림

#### SQLite 데이터베이스
- 객체 그래프 중 일부만 로딩
- 가장 많이 사용

### DataBase ORM이란?
객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것
- 객체 지향 프로그래밍은 클래스를 사용, 관계형 데이터베이스는 테이블을 사용하기에 이들 간의 불일치가 존재하는데 ORM을 통해 SQL을 자동으로 생성하여 불일치를 해결한다.
- JPA가 예시로 존재

#### ORM 장점
- 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있도록 도와준다. 
    - 선언문, 할당, 종료와 같은 부수적인 코드가 없거나 급격히 줄어듬
    - 각종 객체에 대한 코드를 별도로 작성하기에 코드 가독성을 올려줌
    - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성 증가
- 재사용 및 유지보수의 편리성 증가
    - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다
- DBMS에 대한 종속성이 줄어든다.
    - 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하기에 RDBMS의 데이터 구조와 객체지향 모델 사이의 간격을 좁힐 수 있다.

#### ORM 단점
- 완벽한 ORM으로만 서비스를 구현하기 어렵다.
    - 사용하기는 편하지만 설계는 매우 신중해야 한다.
    - 프로젝트 복잡성이 커질경우 난이도 또한 올라간다.
    - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는 등 별도의 튜닝이 필요한 경우가 있다.

### 코어데이터는 ORM일까?
코어데이터가 ORM의 기능을 하고 있는 것은 맞지만 ORM과 같다고는 말할 수 없다. 
관계형 데이터베이스와 소통하기 위해서는 SQL이란 언어가 필요한데 ORM은 내가 앱을 만드는 데 사용하고 있는 언어를 SQL로 번역해주는 것과 같다.

코어데이터는 내부적으로 SQLite를 사용하기에 따로 SQL문을 작성할 필요없이 객체 간 관계를 바탕으로 SQL문을 자동으로 생성해주기 때문에 ORM의 기능을 한다.

### 코어데이터는 DBMS일까?
우선 코어데이터는 DB일까에 대한 내용부터 살펴보자면 DB가 아니다. 단순한 DB의 저장소 기능을 포함하고는 있지만 undo, redo, caching등 다양한 기능이 사용가능하고 객체의 라이프사이클을 관리할 수도 있기 때문에 코어데이터는 DB가 아니다.

DBMS는 DB를 관리하는 시스템이다. 종류로는 관계형 데이터베이스, 네트워크형 데이터베이스, 계층형 데이터베이스 등이 있고 데이터베이스를 직접 관리하는 특징을 가지고 있다.
코어 데이터는 데이터베이스를 직접 관리하지는 않는다. 데이터를 애플리케이션 내의 메모리나 파일 시스템, SQLite 등의 저장소에 저장하고 관리할 수 있지만 데이터베이스를 직접 관리하는 것이 아닌 데이터를 관리하기 위한 인터페이스를 제공하는 것이기 때문에 DBMS는 아니다.

### 코어데이터의 대체제
KeyChain과 UserDefaults가 존재한다.

### Keychain과 UserDefaults는 데이터베이스일까? 코어데이터와 어떤 차이가 있을까?
Keychain과 UserDefaults는 정보를 저장하는 관점에서는 데이터베이스지만 쿼리기능을 제공하지는 않기 때문에 데이터베이스는 아니다.

코어데이터는 데이터베이스 기능을 지원하는 프레임워크이다. 하지만 데이터베이스 기능만 지원하는 것이 아닌 변경사항의 Undo, Redo, 백그라운드 데이터 작업 기능, 동기화 기능, 버전 관리 및 마이그레이션을 지원한다. 

객체 간 연결을 해주고 라이프사이클 관리를 할 수 있기 때문에 대규모 데이터를 저장하거나 체계적인 데이터베이스가 필요할 때 사용하는 것이 적절하다. Keychain과 UserDefaults는 위에서 말한 기능들을 지원하고 있지 않기 때문에 간단한 유저정보를 담을때는 UserDefaults를 중요한 정보를 담고자할 때는 Keychain을 쓰는 게 좋아보인다.


### 참고문서
-[Apple Docs - Core Data](https://developer.apple.com/documentation/coredata)
-[데이터베이스 종류](https://honeywater97.tistory.com/174)
-[데이터베이스 이해하기](https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/)
-[CoreData](https://green1229.tistory.com/58)
-[코어 데이터의 개념](https://ios-development.tistory.com/89)
-[ORM이란](https://gmlwjd9405.github.io/2019/02/01/orm.html)
-[Core Data는 대체 무엇인가???](https://velog.io/@nala/iOS-Core-Data%EB%8A%94-%EB%8C%80%EC%B2%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)
-[코어데이터(Core Data)와 데이터베이스의 차이](https://www.letmecompile.com/%EC%BD%94%EC%96%B4%EB%8D%B0%EC%9D%B4%ED%84%B0core-data%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4/)
-[UserDefaults / CoreData / Realm 간단 비교](https://jeong9216.tistory.com/559)
