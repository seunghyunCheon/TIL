## 230728 클린아키텍처에서 뷰모델과 유즈케이스의 역할

### 왜 고민하게 되었는지
프로젝트 진행 중 나의 정보를 처음 설정하는 부분과 편집하는 부분이 동일한데 재사용하면 되지않을까 싶어서 고민하게 되었다. 하지만 추후 편집화면에서 새로운 기능을 추가해야 한다면? 반대로 생성화면에서 처음에만 입력이 필요한 정보가 생긴다면? 이러한 고민을 하면서 가짜 중복에 대해서 찾아보게되었다. 
가짜 중복은 중복으로 보이는 두 코드 영역이 서로 다른 속도와 다른 이유로 변경이 되는 것을 이야기한다. 생성 화면과 수정 화면은 서로 다른 속도와 다른 이유로 변경이 될 가능성이 크다고 판단했기에 이에 대한 유즈케이스를 분리하기로 했다. (UI는 우선 동일하기 떄문에 하나의 뷰컨과 뷰모델을 사용한다. 하지만 유즈케이스를 달리하면서 확장성을 높이고자 한다.)

### 뷰모델은 무엇일까

뷰모델은 뷰와 비즈니스 로직을 다루는 유즈케이스 사이에서 뷰로직을 갖고있는 객체이다. 만약 뷰모델이 없다면 유즈케이스와 뷰는 직접적으로 의존성을 가지게 되어 테스트가 어려워질 것이다. (뷰를 테스트하는데 비즈니스 로직을 담고있는 객체에 의존해야 하기 때문) 그리고 뷰모델은 유즈케이스에 대한 인터페이스를 갖고있기 때문에 소통할 수 있다. 이 의미는 의존성 역전원칙이 적용된다는 클린아키텍처의 근간을 이루는 원칙이다. 
인터페이스를 갖고있으면 뷰모델을 테스트할 때 Mock 유즈케이스를 주입해서 사용할 수 있기 때문에 테스트하기 수월해진다. 

### 유즈케이스는 무엇일까

유즈케이스는 비즈니스 로직을 다루는 공간이다. 현재 화면에서 필요한 비즈니스 로직에 쓰이는 값과 행동들이 정의되어있으며 UI에 관한 정보가 존재하지 않아야 한다. 그리고 유즈케이스는 repository를 갖고있어 실제 데이터베이스가 변경되도록 트리거 할 수 있게 한다. 여기서 직접변경이 아닌 트리거라고 한 이유는 repository의 remote service나 local persistent service가 직접 데이터베이스에 접근해 변경하기 때문이다. 

### 그래서 결론은?

입력한 정보의 유효성 검증과 input값을 저장하고 있는 useCase, 처음 생성하는 화면일 때 사용하는 CreateUseCase, 수정하는 화면일 때 사용하는 EditUseCase 세 개로 분리했다.
이렇게 분리함으로써 추후 해당화면의 기능 변경이나 추가에 용이하게 대응할 수 있을 것으로 기대된다.

